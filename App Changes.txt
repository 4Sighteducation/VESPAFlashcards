Final Schema for field_3032 (Unified Flashcard System)




{
  "version": "1.0",                           // Schema version for future compatibility
  "lastUpdated": "2025-03-25T09:59:00.000Z",  // Timestamp for tracking changes
  "subjects": [
    {
      "id": "subj_chemistry_1234",            // Unique subject identifier
      "name": "Chemistry",                    // Subject name
      "color": "#3cb44b",                     // Base color for subject
      "examBoard": "AQA",                     // Exam board (optional)
      "examType": "A-Level",                  // Exam type (optional)
      "created": "2025-03-25T06:47:15.181Z",
      "updated": "2025-03-25T06:47:16.227Z"
    }
    // Additional subjects...
  ],
  "topics": [
    {
      // Main topic
      "id": "topic_1",                        // Unique topic identifier (root level)
      "parentId": null,                       // No parent for root-level topics
      "subjectId": "subj_chemistry_1234",     // Reference to parent subject
      "name": "Atomic structure",             // Topic name
      "fullName": "Atomic structure",         // Full display name including parent context
      "color": "#9ec2a2",                     // Topic-specific color (derived from subject)
      "cards": [],                            // Array of card IDs in this topic
      "isEmpty": true,                        // Indicates no cards have been created
      "level": 1,                             // Hierarchical level (1 = main topic)
      "created": "2025-03-25T06:47:15.181Z",
      "updated": "2025-03-25T06:47:16.227Z"
    },
    {
      // Subtopic
      "id": "topic_1.1",                      // Structured ID indicating hierarchy
      "parentId": "topic_1",                  // Reference to parent topic
      "subjectId": "subj_chemistry_1234",     // Reference to parent subject
      "name": "Structure of the atom",        // Topic name (without parent context)
      "fullName": "Atomic structure: Structure of the atom", // Full display name including parent context
      "color": "#8eb392",                     // Slightly different shade from parent
      "cards": [                              // Array of card IDs in this topic
        "card_1742885382298_0_9ragpbtnt",
        "card_1742885382298_1_1ufjlj5gc"
      ],
      "isEmpty": false,                       // Has cards
      "level": 2,                             // Hierarchical level (2 = subtopic)
      "created": "2025-03-25T06:47:15.181Z",
      "updated": "2025-03-25T06:47:16.227Z"
    }
    // Additional topics and subtopics...
  ],
  "cards": [
    {
      "id": "card_1742885382298_0_9ragpbtnt",  // Unique card identifier
      "topicId": "topic_1.1",                  // Reference to parent topic
      "subjectId": "subj_chemistry_1234",      // Reference to subject (for direct filtering)
      "subject": "Chemistry",                  // Subject name (for display and legacy compatibility)
      "topic": "Atomic structure: Structure of the atom", // Topic full name (for display)
      "examBoard": "AQA",                      // Exam board
      "examType": "A-Level",                   // Exam type
      "question": "Which subatomic particle has a charge of +1?",
      "answer": "Proton",
      "detailedAnswer": "Protons are positively charged subatomic particles...",
      "additionalInfo": "Protons are found in the nucleus...",
      "type": "short_answer",                  // Card type
      "cardColor": "#46f0f0",                  // Card-specific color
      "textColor": "",                         // Optional text color
      "boxNum": 1,                             // Spaced repetition box number
      "lastReviewed": null,                    // Last review timestamp
      "nextReviewDate": "2025-03-25T06:49:45.467Z", // Next scheduled review
      "createdAt": "2025-03-25T06:49:42.298Z",
      "updatedAt": "2025-03-25T06:51:09.732Z"
    }
    // Additional cards...
  ],
  "spacedRepetition": {
    "box1": [
      {
        "cardId": "card_1742885382298_0_9ragpbtnt",
        "lastReviewed": "2025-03-25T06:49:42.298Z",
        "nextReviewDate": "2025-03-25T06:49:45.467Z"
      }
      // Additional box 1 cards...
    ],
    "box2": [],
    "box3": [],
    "box4": [],
    "box5": []
  },
  "metadata": {
    "colorMappings": {
      "Chemistry": {
        "base": "#3cb44b",
        "topics": {
          "Atomic structure": "#9ec2a2",
          "Atomic structure: Structure of the atom": "#8eb392"
          // Additional topic colors...
        }
      }
      // Additional subject color mappings...
    },
    "lastSaved": "2025-03-25T09:59:00.000Z",    // When the entire dataset was last saved
    "schemaVersion": "1.0.0",                   // Version of the data schema
    "appVersion": "2.1.0"                       // Version of the application
  }
}

Implementation Plan: Unified Flashcard System with field_3032
Phase 1: Setup & Foundation (Week 1)
Step 1: Create New GitHub Branch
git checkout -b unified-data-model
Step 2: Create UnifiedDataService
Create a new service that will be the central point for all data operations:
* Create src/services/UnifiedFlashcardService.js
* Implement core data structure with TypeScript-like interfaces
* Include methods for initializing the new schema
* Add CRUD operations for subjects, topics, and cards
* Implement utility methods for working with the hierarchical structure
Step 3: Update Field Mappings
* Add field_3032 to Knack field mappings in relevant files
* Prepare Knack integration for using the new field
Step 4: Create Schema Validation Functions
* Implement schema validation to ensure data integrity
* Create helper functions for managing the hierarchical ID system
Phase 2: Topic Generation & Management (Week 1-2)
Step 5: Update TopicSaveStep Component
* Modify to save topic shells directly to the unified data structure
* Implement the creation of hierarchical IDs and parent-child relationships
* Ensure the modal closes and shows immediate feedback after topic creation
Step 6: Update TopicsList Component
* Rebuild to use the new unified data structure
* Add support for displaying hierarchical topics with proper indentation
* Implement "flash" button for empty topics
Step 7: Modify App.js Load Process
* Update to load from the unified data field
* Implement fallback logic during transition
Phase 3: Card Generation & Integration (Week 2)
Step 8: Create Topic-Specific Card Generator
* Create a new generator component or adapt AICardGenerator
* Implement passing of topic context to the generator
* Ensure generated cards are properly linked to their topic
Step 9: Implement Flash Button Logic
* Add click handler for the flash button
* Launch the card generator with topic context
* Implement automatic saving of generated cards into the topic's cards array
Step 10: Update Card Display & Management
* Update FlashcardList to work with the new data structure
* Modify filtering logic to handle hierarchical topics
Phase 4: Spaced Repetition Integration (Week 2-3)
Step 11: Integrate Spaced Repetition Data
* Update the spacedRepetition section of the unified schema
* Ensure card movements between boxes are properly tracked
Step 12: Update SpacedRepetition Component
* Modify to use the new unified data structure
* Ensure review scheduling works with the new schema
Phase 5: Testing & Deployment (Week 3)
Step 13: Comprehensive Testing
* Test the entire workflow from topic creation to card generation to review
* Verify hierarchical topics display and behave correctly
* Test the flash button functionality thoroughly
Step 14: Document Changes
* Update README.md with new data structure and component behavior
* Add migration notes (even though not needed now, helpful for future developers)
Step 15: Deploy to Staging
* Create a pull request
* Deploy to a staging environment for user testing
Step 16: Deploy to Production
* After successful testing, merge to main branch
* Deploy to production
Key Technical Components
1. UnifiedFlashcardService.js
   * Core data management service
   * Handles all CRUD operations on the unified schema
   * Manages hierarchical relationships between topics
2. TopicSaveStep.jsx (Modified)
   * Creates topic shells with hierarchical IDs
   * Directly saves to field_3032
   * Closes modal and shows immediate feedback
3. TopicsList.jsx (Modified)
   * Displays hierarchical topics with proper indentation
   * Shows flash button for empty topics
   * Manages topic expansion/collapse
4. TopicCardGenerator.jsx (New)
   * Generates cards for a specific topic
   * Launched from flash button
   * Automatically saves cards to the topic
5. knack-message-handler.js (Modified)
   * Updated to handle the unified data field
   * Ensures proper verification and synchronization
The advantage of this approach is that you can start with a clean slate while keeping the existing UI largely the same. Users will notice improved performance and reliability without having to learn a new interface.
________________


Revised Implementation Plan: Clean Slate Unified Flashcard System
Phase 1: Setup & Branch Creation (Day 1)
Step 1: Create New GitHub Branch
git checkout -b unified-data-model
Step 2: Create UnifiedFlashcardService
Create a new service as the central point for all data operations:
// src/services/UnifiedFlashcardService.js
class UnifiedFlashcardService {
  // Core data structure
  initializeEmptyDataStructure() {
    return {
      version: "1.0",
      lastUpdated: new Date().toISOString(),
      subjects: [],
      topics: [],
      cards: [],
      spacedRepetition: {
        box1: [], box2: [], box3: [], box4: [], box5: []
      },
      metadata: {
        colorMappings: {},
        lastSaved: new Date().toISOString(),
        schemaVersion: "1.0.0"
      }
    };
  }
  
  // CRUD operations for subjects, topics, cards
  // Hierarchical structure helpers
  // Save & load functions
}
Step 3: Aggressive Service Disabling (Day 1-2)
Comment out or disable these services to ensure a clean slate:
* src/services/TopicCardSyncService.js (COMMENT OUT ENTIRE FILE)
* src/services/TopicPersistenceService.js (COMMENT OUT ENTIRE FILE)
* src/services/EnhancedTopicPersistenceService.js (COMMENT OUT ENTIRE FILE)
* src/services/TopicListService.js (COMMENT OUT ENTIRE FILE)
* src/services/AITopicCacheService.js (MAY KEEP FOR AI GENERATION)
* src/utils/CardDataProcessor.js (REPLACE WITH NEW VERSION)
Phase 2: Clean Slate App Foundation (Days 2-3)
Step 4: Strip Down App.js
Aggressively remove/comment out all data management code in App.js:
// DISABLE THESE IN APP.JS:
// 1. saveData function
// 2. saveToLocalStorage function
// 3. loadFromLocalStorage function
// 4. updateSpacedRepetitionData function
// 5. Auto-save interval useEffect
// 6. All state variables related to fields_2979, field_3011, etc.
// 7. All topic/card synchronization logic
Step 5: Replace with Unified State Management
// ADD TO APP.JS:
const [unifiedData, setUnifiedData] = useState(unifiedFlashcardService.initializeEmptyDataStructure());
const [loading, setLoading] = useState(true);
const [saving, setSaving] = useState(false);


// Derived states
const subjects = useMemo(() => unifiedData.subjects || [], [unifiedData]);
const topics = useMemo(() => unifiedData.topics || [], [unifiedData]);
const cards = useMemo(() => unifiedData.cards || [], [unifiedData]);


// Simplified save function
const saveUnifiedData = useCallback(() => {
  setSaving(true);
  unifiedFlashcardService.saveUnifiedData(unifiedData)
    .then(() => showStatus("Saving..."))
    .catch(err => {
      console.error("Save error:", err);
      showStatus("Error saving");
    });
}, [unifiedData]);


// New auto-save
useEffect(() => {
  let interval = null;
  if (auth && !loading) {
    interval = setInterval(saveUnifiedData, 60000);
  }
  return () => interval && clearInterval(interval);
}, [auth, loading, saveUnifiedData]);
Step 6: Replace Knack Message Handler (Day 3)
Create a streamlined knack-message-handler.js:
// knack-message-handler.js
// DISABLE ALL EXISTING FIELD-SPECIFIC HANDLERS
// REMOVE VERIFICATION FOR fields_2979, field_3011, etc.


// Add field_3032 to mappings
const FIELD_MAPPING = {
  unifiedData: 'field_3032',  // New single source of truth
  lastSaved: 'field_2957'     // Keep for compatibility
};


// Replace save handler with unified version
function saveUnifiedData(recordId, sourceWindow, data) {
  // Prepare payload with only the unified field
  const payload = {
    [FIELD_MAPPING.unifiedData]: JSON.stringify(data),
    [FIELD_MAPPING.lastSaved]: new Date().toISOString()
  };
  
  // Ajax request
  $.ajax({
    url: `${KNACK_API_URL}/objects/${FLASHCARD_OBJECT}/records/${recordId}`,
    type: 'PUT',
    headers: {/*...*/},
    data: JSON.stringify(payload),
    success: function(response) {
      // Send success with the full updated data
      sourceWindow.postMessage({
        type: 'SAVE_RESULT',
        success: true,
        data: {
          [FIELD_MAPPING.unifiedData]: JSON.stringify(data)
        }
      }, '*');
    },
    error: function(error) {
      sourceWindow.postMessage({
        type: 'SAVE_RESULT',
        success: false,
        error: error
      }, '*');
    }
  });
}
Phase 3: Topic Functionality (Days 4-7)
Step 7: Rebuild TopicSaveStep Component
Complete overhaul to save directly to unified structure:
// src/components/NewTopicModal/TopicSaveStep.jsx
function TopicSaveStep({ topics, subject, examBoard, examType, onSave, onClose }) {
  const [saving, setSaving] = useState(false);
  
  const handleSaveTopics = async () => {
    setSaving(true);
    
    try {
      // Create topic objects in the unified format
      const topicObjects = topics.map((topic, index) => {
        const id = `topic_${index + 1}`;
        return {
          id,
          parentId: null, // Root level topics
          subjectId: subject.id,
          name: topic.name,
          fullName: topic.name,
          color: calculateTopicColor(subject.color, index, topics.length),
          cards: [],
          isEmpty: true,
          level: 1,
          created: new Date().toISOString(),
          updated: new Date().toISOString()
        };
      });
      
      // Use UnifiedFlashcardService to add topics
      await unifiedFlashcardService.addTopics(topicObjects);
      
      // Success handling
      setSaving(false);
      
      // Close modal immediately upon success
      onClose();
      
    } catch (error) {
      console.error("Failed to save topics:", error);
      setSaving(false);
    }
  };
  
  return (/* Component JSX */);
}
Step 8: Add Flash Button to Topics List (Days 7-8)
Update TopicsList to add flash button for empty topics:
// src/components/TopicsList.jsx
function TopicsList({ topics, onSelectTopic, selectedTopic }) {
  // Generate flash cards button
  const renderFlashButton = (topic) => {
    if (topic.isEmpty) {
      return (
        <button 
          className="flash-button"
          onClick={(e) => {
            e.stopPropagation();
            launchCardGenerator(topic);
          }}
        >
          <span role="img" aria-label="Generate Cards">⚡</span>
        </button>
      );
    }
    return null;
  };
  
  // Launch card generator for a topic
  const launchCardGenerator = (topic) => {
    // Open card generator modal with topic context
    // This will be implemented in the next phase
  };
  
  return (
    <div className="topics-list">
      {topics.map(topic => (
        <div 
          key={topic.id}
          className={`topic-item ${selectedTopic === topic.id ? 'selected' : ''}`}
          onClick={() => onSelectTopic(topic.id)}
          style={{
            marginLeft: `${(topic.level - 1) * 20}px`,  // Indentation for hierarchy
            backgroundColor: topic.color
          }}
        >
          <span className="topic-name">{topic.name}</span>
          {renderFlashButton(topic)}
        </div>
      ))}
    </div>
  );
}
Phase 4: Card Generation Integration (Days 9-12)
Step 9: Create TopicCardGenerator Component
// src/components/TopicCardGenerator.jsx
function TopicCardGenerator({ topic, onClose, onCardsGenerated }) {
  const [generatedCards, setGeneratedCards] = useState([]);
  
  // Similar AI generation as AICardGenerator but topic-specific
  
  // Save generated cards directly to the topic
  const saveToTopic = async () => {
    try {
      // Add cards to unified structure and link to topic
      await unifiedFlashcardService.addCardsToTopic(topic.id, generatedCards);
      
      // Mark topic as not empty
      await unifiedFlashcardService.updateTopic(topic.id, { isEmpty: false });
      
      // Notify parent
      onCardsGenerated();
      onClose();
    } catch (error) {
      console.error("Error saving cards to topic:", error);
    }
  };
  
  return (/* Component JSX */);
}
Step 10: Modify FlashcardList for Unified Data (Days 12-14)
Update to use the unified data structure:
// src/components/FlashcardList.jsx
function FlashcardList({ onDeleteCard, onUpdateCard }) {
  const { unifiedData, setUnifiedData } = useContext(UnifiedDataContext);
  
  // Get filtered cards using unified data
  const getFilteredCards = () => {
    const { selectedSubject, selectedTopic } = unifiedData.metadata.filters || {};
    
    return unifiedData.cards.filter(card => {
      if (selectedSubject && card.subjectId !== selectedSubject) return false;
      if (selectedTopic && card.topicId !== selectedTopic) return false;
      return true;
    });
  };
  
  // Delete card from unified structure
  const handleDeleteCard = async (cardId) => {
    await unifiedFlashcardService.deleteCard(cardId);
    // State update handled through context
  };
  
  return (/* Component JSX */);
}
Phase 5: Spaced Repetition Integration (Days 15-18)
Step 11: Update Spaced Repetition Component
Modify to use unified data structure:
// src/components/SpacedRepetition.jsx
function SpacedRepetition({ onReturnToBank }) {
  const { unifiedData, setUnifiedData } = useContext(UnifiedDataContext);
  const [currentBox, setCurrentBox] = useState(1);
  
  // Get cards for current box
  const getCardsForCurrentBox = () => {
    const boxKey = `box${currentBox}`;
    const boxItems = unifiedData.spacedRepetition[boxKey] || [];
    
    return boxItems.map(item => {
      const card = unifiedData.cards.find(c => c.id === item.cardId);
      return {
        ...card,
        isReviewable: isCardDueForReview(item.nextReviewDate),
        nextReviewDate: item.nextReviewDate
      };
    }).filter(card => card); // Remove undefined
  };
  
  // Move card to a box
  const moveCardToBox = async (cardId, box) => {
    await unifiedFlashcardService.moveCardToBox(cardId, box);
    // State update handled through context
  };
  
  return (/* Component JSX */);
}
Phase 6: Testing & Deployment (Days 19-21)
Step 12: Comprehensive Testing
* Write test cases for each component
* End-to-end testing of the full workflow
Step 13: Documentation
Create detailed documentation in the README:
* Architecture overview
* Data schema documentation
* Usage instructions for developers
Step 14: Final Repository Cleanup
* Remove all commented-out legacy code
* Clean up any debug logs
* Ensure code follows consistent style
Step 15: Deployment
* Create pull request
* Merge to main after review
* Deploy to production