import React, { useState, useEffect, useCallback } from "react";
import "./AICardGenerator.css";
import Flashcard from './Flashcard';
// import { generateTopicPrompt } from '../prompts/topicListPrompt'; // REMOVED - Backend handles prompts
import TopicHub from '../components/TopicHub'; // Keep for potential future use or topic display
import saveQueueService from '../services/SaveQueueService';
import { useWebSocket } from '../hooks/useWebSocket'; // ADDED

// Constants for question types and exam boards
const QUESTION_TYPES = [
  { value: "short_answer", label: "Short Answer" },
  { value: "multiple_choice", label: "Multiple Choice" },
  { value: "essay", label: "Essay Style" },
  { value: "acronym", label: "Acronym" }
];

const EXAM_BOARDS = [
  { value: "AQA", label: "AQA" },
  { value: "Edexcel", label: "Edexcel" },
  { value: "OCR", label: "OCR" },
  { value: "WJEC", label: "WJEC" },
  { value: "SQA", label: "SQA" },
  { value: "International Baccalaureate", label: "International Baccalaureate" },
  { value: "Cambridge International", label: "Cambridge International" }
];

const EXAM_TYPES = [
  { value: "GCSE", label: "GCSE" },
  { value: "A-Level", label: "A-Level" },
  { value: "IB", label: "International Baccalaureate" },
  { value: "AP", label: "Advanced Placement" },
  { value: "Scottish Higher", label: "Scottish Higher" },
  { value: "BTEC", label: "BTEC / Vocational" },
  { value: "Other", label: "Other" }
];

// Function to return compatible exam boards for each exam type
const boardsForType = (examType) => {
  // All boards are available for all exam types by default
  return EXAM_BOARDS.map(board => board.value);
};

// Color palette for cards
const BRIGHT_COLORS = [
  "#e6194b", "#3cb44b", "#ffe119", "#0082c8", "#f58231",
  "#911eb4", "#46f0f0", "#f032e6", "#d2f53c", "#fabebe",
  "#008080", "#e6beff", "#aa6e28", "#fffac8", "#800000",
  "#aaffc3", "#808000", "#ffd8b1", "#000080", "#808080",
  "#FF69B4", "#8B4513", "#00CED1", "#ADFF2F", "#DC143C"
];

// API keys - REMOVED - Handled by backend
// const OPENAI_API_KEY = process.env.REACT_APP_OPENAI_KEY || "your-openai-key";

// Debug logging helper
const debugLog = (title, data) => {
  console.log(`%c${title}`, 'color: #5d00ff; font-weight: bold; font-size: 12px;');
  console.log(JSON.stringify(data, null, 2));
  return data; // Return data for chaining
};

// Helper function for delays
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const AICardGenerator = ({ 
  onAddCard, 
  onClose, 
  subjects = [], 
  auth, 
  userId,
  initialSubject = "",
  initialTopic = "",
  examBoard = "AQA",
  examType = "A-Level",
  recordId,
  initialTopicsProp, // Topics possibly coming from FlashcardList
  onFinalizeTopics // Callback possibly related to TopicHub interaction
}) => {
  // WebSocket Hook Usage - ADDED
  const { sendMessage, lastMessage, readyState } = useWebSocket();
  const isWsConnected = readyState === WebSocket.OPEN;

  // Step management state
  const [currentStep, setCurrentStep] = useState(1);
  const totalSteps = 5; // Adjusted steps: 1:Meta, 2:Subject, 3:Topic Gen/Select, 4:Card Options, 5:Review Cards
  
  // Form data state
  const [formData, setFormData] = useState({
    examBoard: examBoard,
    examType: examType,
    subject: initialSubject,
    newSubject: "",
    topic: initialTopic,
    newTopic: "",
    numCards: 5,
    questionType: "multiple_choice", // Default question type
    subjectColor: BRIGHT_COLORS[0], // Default color
  });
  
  // Processing states
  const [isGenerating, setIsGenerating] = useState(false); // Covers both topic and card generation
  const [error, setError] = useState(null);
  const [loadingStatus, setLoadingStatus] = useState(''); // ADDED for WS status messages
  
  // Results states
  const [generatedCards, setGeneratedCards] = useState([]);
  
  // State for available subjects and topics based on selection
  const [availableSubjects, setAvailableSubjects] = useState([]);
  const [availableTopics, setAvailableTopics] = useState([]); // Topics generated by WS or passed via prop
  const [hierarchicalTopics, setHierarchicalTopics] = useState([]); // If needed for display

  // UI States
  const [showTopicModal, setShowTopicModal] = useState(false); // Potentially to show TopicHub or similar
  const [successModal, setSuccessModal] = useState({ show: false, addedCards: [] });
  const [showSaveTopicDialog, setShowSaveTopicDialog] = useState(false); // ADDED
  const [showSaveConfirmation, setShowSaveConfirmation] = useState(false);
  const [showTopicConfirmation, setShowTopicConfirmation] = useState(false);
  const [selectedTopicForConfirmation, setSelectedTopicForConfirmation] = useState("");
  const [showOptionsExplanationModal, setShowOptionsExplanationModal] = useState(false);
  const [selectedTopic, setSelectedTopic] = useState(null); // Currently selected topic object {id, topic, mainTopic, subtopic}
  
  // Operation tracking state
  const [pendingOperations, setPendingOperations] = useState({
    save: false,
    refresh: false,
    addToBank: false
  });

  // Misc State
  const [operationSuccess, setOperationSuccess] = useState(false);
  const [savedCount, setSavedCount] = useState(0);
  const [showSuccessModal, setShowSuccessModal] = useState(false); // Duplicate? Consolidate with successModal state


// Initialize availableTopics state when initialTopicsProp changes
useEffect(() => {
  if (initialTopicsProp && Array.isArray(initialTopicsProp) && initialTopicsProp.length > 0) {
      // Ensure passed topics have IDs
       const topicsWithIds = initialTopicsProp.map((topic, index) => ({
            ...topic,
            id: topic.id || `prop_topic_${Date.now()}_${index}` // Generate ID if missing
        }));
      setAvailableTopics(topicsWithIds);
      setHierarchicalTopics(topicsWithIds); // Also set hierarchical if needed
      console.log(`[AICardGenerator] Initialized with ${topicsWithIds.length} topics from prop.`);
  } else {
    setAvailableTopics([]);
    setHierarchicalTopics([]);
  }
}, [initialTopicsProp]); 

  // Token Refresh Logic (Keep if still needed for parent communication)
  const requestTokenRefresh = useCallback(async () => {
    console.log(`[${new Date().toISOString()}] AICardGenerator requesting token refresh`);
      // ... (rest of the token refresh logic remains unchanged) ...
    if (!window.tokenRefreshInProgress) {
      window.tokenRefreshInProgress = true;
    } else {
         console.log("Token refresh already in progress, waiting...");
         // ... (waiting logic) ...
       }
    try {
      if (window.parent && window.parent !== window) {
           // ... (postMessage logic with retries) ...
      }
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error in token refresh:`, error);
          window.tokenRefreshInProgress = false; // Ensure flag is reset on error
       } finally {
           // Ensure the flag is always reset eventually
           // Use a timeout just in case the promise logic fails to reset it
           setTimeout(() => { window.tokenRefreshInProgress = false; }, 5000);
       }
       return Promise.resolve(false); // Default return if no parent communication
  }, []);


  // Effect to update available subjects (Based on exam type or props)
  useEffect(() => {
    // Logic to determine available subjects based on formData.examType or passed subjects prop
    // This part seems mostly UI logic and can remain largely unchanged.
    // Example: Combine props.subjects with predefined lists based on examType.
    const predefinedSubjects = { /* ... your predefined subject lists ... */ };
    const currentExamTypeSubjects = predefinedSubjects[formData.examType] || [];
    const propSubjectNames = Array.isArray(subjects) ? subjects.map(s => typeof s === 'object' ? s.name : s) : [];
    const combined = [...new Set([...propSubjectNames, ...currentExamTypeSubjects])].sort();
    setAvailableSubjects(combined);

  }, [formData.examType, subjects]);


  // --- WebSocket Message Handling --- ADDED ---
  useEffect(() => {
    if (lastMessage !== null) {
      try {
        const message = JSON.parse(lastMessage.data);
        debugLog('AICardGenerator received WS message:', message);

        switch (message.type) {
          case 'topicResults':
            if (message.action === 'generateTopics') {
              console.log(`Received ${message.topics?.length || 0} topics from WebSocket.`);
              // Ensure topics have unique IDs if needed (backend should ideally provide them)
              const topicsWithIds = (message.topics || []).map((topic, index) => ({
                ...topic,
                id: topic.id || `ws_topic_${Date.now()}_${index}` // Generate unique frontend ID if missing
              }));
              setAvailableTopics(topicsWithIds);
              setHierarchicalTopics(topicsWithIds); // Also update hierarchical topics if used for display
              setIsGenerating(false);
              setLoadingStatus('Topic list generated.');
              setError(null);
            }
            break;

          case 'cardResults':
            if (message.action === 'generateCards') {
              console.log(`Received ${message.cards?.length || 0} cards from WebSocket.`);

              // Process cards: Add frontend-specific metadata like unique ID and color
              const finalSubject = formData.subject || formData.newSubject || initialSubject || "General";
              const finalTopic = formData.topic || formData.newTopic || initialTopic || "General";
              const finalExamType = formData.examType || examType || "General";
              const finalExamBoard = formData.examBoard || examBoard || "General";
              const finalQuestionType = formData.questionType || "short_answer";
              const cardColor = formData.subjectColor || BRIGHT_COLORS[0]; // Get current color from form state

              const processedCards = (message.cards || []).map((card, index) => {
                  const id = `card_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`; // Unique frontend ID
                  const ensuredCardColor = cardColor || "#3cb44b"; // Ensure color exists

                  // Determine front/back based on card structure from backend
                  let front = card.question || card.acronym || 'Question Not Available';
                  let back = card.detailedAnswer || card.explanation || 'Answer Not Available';
                  if (card.questionType === 'multiple_choice' && card.options && card.correctAnswer) {
                      const correctOptionText = card.correctAnswer;
                      // Try to find index robustly
                      let correctIndex = card.options.findIndex(opt => opt && opt.trim() === correctOptionText.trim());
                       if (correctIndex === -1) { // Fallback: case-insensitive match
                            correctIndex = card.options.findIndex(opt => opt && opt.trim().toLowerCase() === correctOptionText.trim().toLowerCase());
                       }
                       if (correctIndex === -1) { // Fallback: default to first option if still not found
                           console.warn(`Could not match correctAnswer "${correctOptionText}" to options: ${JSON.stringify(card.options)}. Defaulting to option A.`);
                           correctIndex = 0;
                       }
                      const letter = correctIndex !== -1 ? String.fromCharCode(97 + correctIndex) : '?';
                      back = `Correct Answer: ${letter}) ${card.options[correctIndex]}`; // Use the actual option text
                  }

                  // Add/overwrite necessary frontend fields
                  return {
                      ...card, // Spread the card data from backend first
                      id, // Frontend unique ID
                      subject: card.subject || finalSubject, // Use backend value or fallback
                      topic: card.topic || finalTopic,       // Use backend value or fallback
                      examType: card.examType || finalExamType, // Use backend value or fallback
                      examBoard: card.examBoard || finalExamBoard, // Use backend value or fallback
                      questionType: card.questionType || finalQuestionType, // Use backend value or fallback
                      cardColor: ensuredCardColor, // Add color based on form state
                      baseColor: ensuredCardColor, // Add baseColor
                      timestamp: new Date().toISOString(),
                      boxNum: 1, // Start in box 1
                      front: front, // Set calculated front
                      back: back,   // Set calculated back
                       // Add savedOptions backup for multiple choice if needed
                      ...(card.questionType === 'multiple_choice' && card.options && { savedOptions: [...card.options] }),
                  };
              });

              debugLog("PROCESSED CARDS FROM WEBSOCKET", processedCards.map(c => ({ id: c.id, subject: c.subject, topic: c.topic, type: c.questionType })));
              setGeneratedCards(processedCards);
              setIsGenerating(false);
              setLoadingStatus(`${processedCards.length} Cards generated.`);
              setError(null);
            }
            break;

          case 'status':
             // Update UI based on status message
            if (message.action === 'generateTopics' || message.action === 'generateCards') {
                 setLoadingStatus(message.message || 'Processing...');
                 // Ensure loading state is active only if status implies ongoing generation
                 const lowerCaseMsg = message.message?.toLowerCase() || '';
                 if (lowerCaseMsg && !lowerCaseMsg.includes('completed') && !lowerCaseMsg.includes('error') && !lowerCaseMsg.includes('generated') && !lowerCaseMsg.includes('received')) {
                     setIsGenerating(true);
                 } else {
                     // If status seems final, ensure loading state is off (belt and suspenders)
                     setIsGenerating(false);
                 }
            }
            break;

          case 'error':
             // Handle errors from the WebSocket server
            if (message.action === 'generateTopics' || message.action === 'generateCards') {
                 console.error(`WebSocket Error (${message.action}):`, message.message);
                 setError(`AI Generation Error: ${message.message || 'Unknown server error'}`);
                 setIsGenerating(false);
                 setLoadingStatus('Error occurred.');
                 // Clear results on error
                 if (message.action === 'generateTopics') { setAvailableTopics([]); setHierarchicalTopics([]); }
                 if (message.action === 'generateCards') setGeneratedCards([]);
            } else {
                // Handle other potential WS errors if needed
                console.error(`General WebSocket Error:`, message.message);
                setError(`Server Error: ${message.message || 'Unknown communication error'}`);
                setIsGenerating(false); // Stop any loading indicators
                setLoadingStatus('Error occurred.');
            }
            break;

          case 'info':
             // Handle general info messages (e.g., 'Connected')
             console.log('WebSocket Info:', message.message);
             if (message.message?.toLowerCase().includes('connected')) {
                 setError(null); // Clear connection errors if we reconnect
             }
             break;
          default:
            console.warn('Received unknown WebSocket message type:', message.type);
        }
      } catch (e) {
        console.error('Failed to parse WebSocket message:', e, 'Raw data:', lastMessage?.data);
        setError('Error processing server message.'); // Set a generic error for parsing failures
        setIsGenerating(false);
        setLoadingStatus('Error occurred.');
      }
    }
  }, [lastMessage, formData.subjectColor, formData.subject, formData.newSubject, formData.topic, formData.newTopic, formData.examType, formData.examBoard, formData.questionType, initialSubject, initialTopic, examBoard, examType]); // Added dependencies to ensure correct metadata processing


   // Rewritten generateTopics function to use WebSocket - MOVED EARLIER
   const generateTopics = useCallback(async (genExamBoard, genExamType, genSubject) => {
     if (!genExamBoard || !genExamType || !genSubject) {
       console.error("generateTopics: Missing required parameters.");
       setError("Missing exam board, type, or subject to generate topics.");
       return;
     }
     if (!isWsConnected) {
         console.error("generateTopics: WebSocket not connected.");
         setError("Not connected to generation service. Please wait or refresh.");
         setIsGenerating(false);
         setLoadingStatus('');
         return;
       }
       
     console.log(`Requesting topic generation via WebSocket for ${genSubject} (${genExamBoard} ${genExamType})`);
             setError(null);
     setAvailableTopics([]); // Clear previous topics before new request
     setHierarchicalTopics([]);
     setIsGenerating(true);
     setLoadingStatus('Requesting topic list...');

     sendMessage(JSON.stringify({
       action: 'generateTopics',
       data: {
         examBoard: genExamBoard,
         examType: genExamType,
         subject: genSubject
       }
     }));
     // Response handled by useEffect watching lastMessage
   }, [sendMessage, isWsConnected]); // Dependencies: sendMessage and readyState (isWsConnected)


  // Effect to auto-generate topics when entering Step 3 if needed
  useEffect(() => {
     // Conditions:
     // - In Step 3
     // - Have necessary exam/subject details
     // - Not currently generating
     // - WebSocket is connected
     // - Topics haven't already been generated *for these exact parameters* (optional optimization)
     if (currentStep === 3 && (formData.subject || formData.newSubject) && formData.examBoard && formData.examType && !isGenerating && isWsConnected) {
       const subjectToGenerate = formData.subject || formData.newSubject;
       // Optional: Check if topics for these exact params already exist to avoid re-request
       // const alreadyGenerated = availableTopics.length > 0 && availableTopics[0]?.subject === subjectToGenerate && ...;
       // if (!alreadyGenerated) {
          console.log(`AICardGenerator: Requesting topics via WS for: ${subjectToGenerate} (${formData.examBoard} ${formData.examType})`);
          generateTopics(formData.examBoard, formData.examType, subjectToGenerate);
       // }
     }
     // Clear topics if exam/subject details become invalid in Step 3
     else if (currentStep === 3 && !(formData.subject || formData.newSubject) && !(formData.examBoard && formData.examType)) {
         setAvailableTopics([]);
         setHierarchicalTopics([]);
     }
   }, [currentStep, formData.subject, formData.newSubject, formData.examBoard, formData.examType, isGenerating, isWsConnected, generateTopics]); // Dependencies include generateTopics


  // REMOVED: getFallbackTopics function

  // REMOVED generateTopics definition from here (MOVED EARLIER)

 // --- Functions related to saving/loading topic lists (if kept) ---
  const saveTopicList = () => {
      // ... (logic for saving the current availableTopics list - likely needs update if using TopicHub)
      console.warn("saveTopicList function needs review/update for WebSocket integration.");
       setShowSaveTopicDialog(true); // Example UI interaction
  };

  // REMOVED: generateId function (IDs generated differently now)

  const saveTopicListToKnack = async (topicLists) => {
     // ... (This likely uses saveQueueService or similar, may not need direct changes if service is robust)
     console.warn("saveTopicListToKnack needs review - ensure it uses correct data structure.");
      try {
         await saveQueueService.add("SAVE_TOPIC_LISTS", { userId, recordId, topicLists });
         // ... UI updates on success
    } catch (error) {
         // ... UI updates on error
    }
  };
  
  const loadTopicList = (listId) => {
      // ... (Logic to load a previously saved list - may involve backend interaction)
      console.warn("loadTopicList function needs implementation/review.");
  };

  const deleteTopicList = (listId) => {
      // ... (Logic to delete a saved list - may involve backend interaction)
      console.warn("deleteTopicList function needs implementation/review.");
  };

  const renderSavedTopicLists = () => {
      // ... (UI rendering for saved lists)
      return <div>Saved Topic Lists UI (Not Implemented)</div>;
  };

  const generateCardsFromTopicList = (list) => {
      // ... (Logic to take a loaded topic list and proceed to card generation)
       console.warn("generateCardsFromTopicList function needs review.");
       if (list && list.topics) {
           setAvailableTopics(list.topics);
           setHierarchicalTopics(list.topics);
           // Maybe auto-advance step?
           // setCurrentStep(4);
       }
  };

  const renderSaveTopicDialog = () => {
     // ... (UI for the save dialog)
      if (!showSaveTopicDialog) return null;
    return (
          <div>Save Topic Dialog UI (Not Implemented)</div>
      );
  };
  // --- End Topic List Functions ---


  // Form change handler
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
      setFormData(prev => ({ 
        ...prev, 
      [name]: type === 'checkbox' ? checked : value
    }));

    // Reset topic if subject changes
    if (name === 'subject' || name === 'newSubject') {
        setFormData(prev => ({ ...prev, topic: '', newTopic: ''}));
        setAvailableTopics([]); // Clear generated topics
        setHierarchicalTopics([]);
        setSelectedTopic(null); // Deselect topic
    }
    // Reset new subject if existing subject is selected
     if (name === 'subject' && value) {
         setFormData(prev => ({ ...prev, newSubject: '' }));
     }
      // Reset subject if new subject is typed
     if (name === 'newSubject' && value) {
         setFormData(prev => ({ ...prev, subject: '' }));
     }
       // Reset new topic if existing topic is selected
     if (name === 'topic' && value) {
         setFormData(prev => ({ ...prev, newTopic: '' }));
          // Find and set the selected topic object
         const topicObj = availableTopics.find(t => t.topic === value || t.id === value); // Match by name or ID
         setSelectedTopic(topicObj || null);
     }
      // Reset topic if new topic is typed
     if (name === 'newTopic' && value) {
         setFormData(prev => ({ ...prev, topic: '' }));
         setSelectedTopic(null);
     }
  };

  // Step navigation
  const handleNextStep = () => {
    if (canProceed()) {
        // Logic before advancing step if needed (e.g., trigger generation)
        if (currentStep === 3 && !formData.topic && !formData.newTopic) {
            setError("Please select or enter a topic before proceeding.");
            return; // Prevent advancing without a topic selected/entered in step 3
        }
         // Trigger card generation automatically when moving from step 4 to 5
        if (currentStep === 4) {
            console.log("Moving to Step 5, triggering card generation...");
            generateCards(); // Generate cards before showing step 5
        }

      setCurrentStep(prev => Math.min(prev + 1, totalSteps));
      setError(null); // Clear errors on step change
    } else {
        console.log("Cannot proceed, validation failed for step", currentStep);
        // Error state should be set by canProceed logic if validation fails
    }
  };

  const handlePrevStep = () => {
    setCurrentStep(prev => Math.max(prev - 1, 1));
    setError(null); // Clear errors on step change
  };

  // Validation logic for proceeding
  const canProceed = () => {
    setError(null); // Clear previous validation errors
    switch (currentStep) {
      case 1: // Exam Details
        if (!formData.examBoard || !formData.examType) {
            setError("Please select both Exam Board and Exam Type.");
            return false;
        }
        return true;
      case 2: // Subject
        if (!formData.subject && !formData.newSubject) {
            setError("Please select or enter a Subject.");
            return false;
        }
        return true;
      case 3: // Topic (Selection/Generation)
        // Check if topics are available OR if user entered a new topic
        const hasTopicSelection = formData.topic || formData.newTopic;
        // If generating, allow proceed? Maybe not, wait for generation.
        if (isGenerating && availableTopics.length === 0) {
             setError("Please wait for topics to generate.");
             return false;
        }
        // If not generating, require a selected or new topic
        if (!isGenerating && !hasTopicSelection) {
             setError("Please select a topic from the list or enter a new one.");
             return false;
        }
        // If topics loaded but none selected/entered
        if (availableTopics.length > 0 && !hasTopicSelection) {
             setError("Please select a topic from the list or enter a new one.");
             return false;
        }
        return true; // Allow proceed if generating is done and a topic is selected/entered, or if entering new topic
      case 4: // Card Options
        // Basic check, specific options validation might be needed
        if (formData.numCards <= 0 || !formData.questionType) {
            setError("Please set the number of cards and select a question type.");
            return false;
        }
        return true;
      case 5: // Review Cards - Always allow going back from here
        return true; // Or maybe check if cards exist? generateCards called on entering this step
      default:
        return false;
    }
  };


  // Rewritten generateCards function to use WebSocket - MOVED EARLIER
  const generateCards = useCallback(async () => {
    // Prevent generation if already generating or WebSocket isn't ready
    if (isGenerating) {
        console.log("generateCards: Already generating.");
        return;
    }
     if (!isWsConnected) {
         console.error("generateCards: WebSocket not connected.");
         setError("Not connected to generation service. Please wait or refresh.");
         setIsGenerating(false);
         setLoadingStatus('');
         return;
     }

    // Clear previous results and errors
    setGeneratedCards([]);
    setError(null);
    setIsGenerating(true);
    setLoadingStatus('Requesting card generation...');

    // Capture stable values from formData at the time of the request
    const finalExamBoard = formData.examBoard || examBoard || "General";
    const finalExamType = formData.examType || examType || "Course";
    const finalSubject = formData.subject || formData.newSubject || initialSubject || "General";
    // Use selected topic object's topic name, fallback to form input, fallback to initial prop
    const finalTopic = selectedTopic?.topic || formData.topic || formData.newTopic || initialTopic || "General";
    const numCardsValue = formData.numCards || 5;
    const questionTypeValue = formData.questionType || "short_answer";

    // Basic validation before sending
    if (!finalSubject || !finalTopic) {
        console.error("generateCards: Missing subject or topic.");
        setError("Please ensure a subject and topic are selected or entered.");
        setIsGenerating(false);
        setLoadingStatus('');
        return;
    }

    // Assign color if needed (Should ideally be set when subject is chosen)
    let cardColor = formData.subjectColor;
    if (!cardColor) {
         // Simple random assignment if no color exists in state
         cardColor = BRIGHT_COLORS[Math.floor(Math.random() * BRIGHT_COLORS.length)];
         setFormData(prev => ({ ...prev, subjectColor: cardColor })); // Update state
         console.log(`Assigned random color ${cardColor} for subject ${finalSubject}`);
    }


    const payload = {
          examBoard: finalExamBoard,
      examType: finalExamType,
          subject: finalSubject,
          topic: finalTopic,
      numCards: numCardsValue,
      questionType: questionTypeValue
    };

    debugLog("Sending generateCards request via WebSocket", payload);

    sendMessage(JSON.stringify({
      action: 'generateCards',
      data: payload
    }));
    // Response handled by useEffect watching lastMessage

  }, [formData, examBoard, examType, initialSubject, initialTopic, subjects, selectedTopic, sendMessage, isWsConnected, isGenerating]); // Added dependencies


  // Effect to generate cards on step entry (Step 5) - MODIFIED for WS
  useEffect(() => {
     // Generate cards when entering step 5 IF cards aren't already generated/generating
     if (currentStep === 5 && generatedCards.length === 0 && !isGenerating && isWsConnected) {
       console.log("AICardGenerator: Triggering card generation on step 5 entry via WS");
       generateCards(); // Call the WebSocket-based function
     }
   }, [currentStep, generatedCards.length, isGenerating, isWsConnected, generateCards]); // Added isWsConnected


  // REMOVED: cleanOpenAIResponse function

  // handleAddCard function - Updated to use stable data & communicate via parent/service
  const handleAddCard = (card) => {
    if (pendingOperations.addToBank || card.processing) {
      console.log("Add to bank operation already in progress or card processing, ignoring duplicate request");
      return;
    }
    if (!card || !card.id) {
      console.error("handleAddCard: Invalid card data provided:", card);
      setError("Cannot add invalid card data.");
      return;
    }

    setPendingOperations(prev => ({ ...prev, addToBank: true }));
    setGeneratedCards(prev => prev.map(c => 
      c.id === card.id ? {...c, processing: true} : c
    ));

    // CRITICAL: Store stable local variables from form state or props at the time of click
    const localExamBoard = formData.examBoard || examBoard || "General";
    const localExamType = formData.examType || examType || "Course";
    const localSubject = formData.subject || formData.newSubject || initialSubject || "General";
    // Use topic from the *card object itself* first, as it came from generation, fallback to form state
    const localTopic = card.topic || formData.topic || formData.newTopic || initialTopic || "General";
    const topicId = selectedTopic?.id || card.topicId || null; // Prefer ID from selectedTopic object if available
    
    const recordIdToUse = recordId || window.recordId || ''; // Get recordId reliably
    const userIdToUse = userId || window.VESPA_USER_ID || "current_user"; // Get userId reliably
    
    debugLog("Adding card with stable metadata", {
      topicId,
      examType: localExamType,
      examBoard: localExamBoard,
      subject: localSubject,
      topic: localTopic, // Use the determined localTopic
      cardId: card.id,
      recordId: recordIdToUse,
      userId: userIdToUse
    });

    try {      
      // Enrich card with guaranteed consistent metadata from stable vars + add timestamps etc.
      const enrichedCard = {
        ...card, // Spread original card data (already processed by WS handler)
        examBoard: localExamBoard, // Overwrite with stable value
        examType: localExamType,   // Overwrite with stable value
        subject: localSubject,     // Overwrite with stable value
        topic: localTopic,         // Overwrite with stable value
        topicId: topicId,          // Add topicId if available
        created: new Date().toISOString(),
        updated: new Date().toISOString(),
        lastReviewed: new Date().toISOString(), // Initialize review dates
        nextReviewDate: new Date().toISOString(),
        boxNum: card.boxNum || 1, // Ensure boxNum exists
         // Ensure options/savedOptions are handled correctly for MCQs
        ...(card.questionType === 'multiple_choice' && {
             options: card.options || card.savedOptions || [],
             savedOptions: card.savedOptions || card.options || [],
             correctAnswer: card.correctAnswer || (card.options ? card.options[0] : null) // Ensure correctAnswer exists
        }),
      };

      // Remove the temporary processing flag before sending
      delete enrichedCard.processing;

      // --- Communication Method ---
      // Prioritize using the onAddCard prop if provided (likely for direct parent state update)
      let addedLocally = false;
      if (typeof onAddCard === 'function') {
        try {
          onAddCard(enrichedCard);
          console.log("Card passed to onAddCard callback");
          addedLocally = true;
        } catch (callbackError) {
          console.error("Error in onAddCard callback:", callbackError);
           setError(`Error adding card locally: ${callbackError.message}`);
           // Don't necessarily stop the save queue attempt
        }
      }

       // Use Save Queue Service as the primary method for persistence
       console.log("Adding card via Save Queue Service");
       saveQueueService.add("ADD_CARD_TO_BANK", { // Use a specific action type
          recordId: recordIdToUse, // Pass necessary identifiers
            userId: userIdToUse,
          card: enrichedCard // Send the fully enriched card object
       })
       .then(() => {
           console.log(`Card ${enrichedCard.id} added to save queue.`);
           // Update UI optimistically or based on service feedback
            setSuccessModal({ show: true, addedCards: [enrichedCard] }); // Show success
            setTimeout(() => setSuccessModal(prev => ({ ...prev, show: false })), 3000);

           // Remove the card from the generated list after successful queuing
           setGeneratedCards(prev => prev.filter(c => c.id !== card.id));
           setSavedCount(prev => prev + 1); // Increment saved counter
       })
       .catch(queueError => {
           console.error("Error adding card to save queue:", queueError);
           setError(`Failed to queue card for saving: ${queueError.message}`);
           // Revert processing state on the card in UI
              setGeneratedCards(prev => prev.map(c => 
              c.id === card.id ? {...c, processing: false } : c
            ));
       })
       .finally(() => {
           // Always reset the pending operation flag
          setPendingOperations(prev => ({ ...prev, addToBank: false }));
           // Reset card-specific processing flag just in case
        setGeneratedCards(prev => prev.map(c => 
              c.id === card.id ? {...c, processing: false } : c
        ));
       });

    } catch (error) {
      console.error("Error handling add card:", error);
      setError(`Error adding card: ${error.message}. Please try again.`);
      setGeneratedCards(prev => prev.map(c => 
        c.id === card.id ? {...c, processing: false} : c
      ));
      setPendingOperations(prev => ({ ...prev, addToBank: false }));
    }
  };

    
  // handleAddAllCards function - Updated to use SaveQueueService
  const handleAddAllCards = () => {
    if (pendingOperations.addToBank) {
      console.log("Add all operation already in progress, ignoring duplicate click");
      return;
    }
    if (generatedCards.length === 0) {
        setError("No cards to add.");
      return;
    }
    
    setPendingOperations(prev => ({ ...prev, addToBank: true }));
    // Mark all cards as processing
    setGeneratedCards(prev => prev.map(c => ({...c, processing: true })));
    
    // CRITICAL: Store stable local variables
    const localExamBoard = formData.examBoard || examBoard || "General";
    const localExamType = formData.examType || examType || "Course";
    const localSubject = formData.subject || formData.newSubject || initialSubject || "General";
    // Use topic from the *first card* as representative, fallback to form state
    const localTopic = generatedCards[0]?.topic || formData.topic || formData.newTopic || initialTopic || "General";
    const topicId = selectedTopic?.id || generatedCards[0]?.topicId || null;
    
    const recordIdToUse = recordId || window.recordId || '';
    const userIdToUse = userId || window.VESPA_USER_ID || "current_user";

    debugLog("Starting add all cards with stable metadata", {
      examType: localExamType, examBoard: localExamBoard, subject: localSubject, topic: localTopic,
      cardCount: generatedCards.length, recordId: recordIdToUse, userId: userIdToUse
    });
    
    try {
        // Enrich all cards consistently before sending
        const cardsToAdd = generatedCards.map(card => {
             const enrichedCard = {
                ...card, // Spread original card data (already processed by WS handler)
                examBoard: localExamBoard, subject: localSubject, topic: localTopic, examType: localExamType,
                topicId: topicId,
                created: new Date().toISOString(), updated: new Date().toISOString(),
                lastReviewed: new Date().toISOString(), nextReviewDate: new Date().toISOString(),
                boxNum: card.boxNum || 1,
                 ...(card.questionType === 'multiple_choice' && {
                     options: card.options || card.savedOptions || [],
                     savedOptions: card.savedOptions || card.options || [],
                      correctAnswer: card.correctAnswer || (card.options ? card.options[0] : null)
                 }),
             };
             delete enrichedCard.processing; // Remove temp flag
             return enrichedCard;
        });

        // Use Save Queue Service for batch add
        console.log(`Adding batch of ${cardsToAdd.length} cards via Save Queue Service`);
        saveQueueService.add("ADD_CARDS_BATCH", { // Use a specific batch action type
            recordId: recordIdToUse,
            userId: userIdToUse,
            cards: cardsToAdd // Send the array of enriched cards
         })
         .then(() => {
             console.log(`${cardsToAdd.length} cards added to save queue.`);
             setSuccessModal({ show: true, addedCards: cardsToAdd });
             setTimeout(() => setSuccessModal(prev => ({ ...prev, show: false })), 3000);

             setSavedCount(prev => prev + cardsToAdd.length);
             setGeneratedCards([]); // Clear the list after successful queuing
         })
         .catch(queueError => {
             console.error("Error adding card batch to save queue:", queueError);
             setError(`Failed to queue cards for saving: ${queueError.message}`);
             // Revert processing state on UI
             setGeneratedCards(prev => prev.map(c => ({...c, processing: false })));
         })
         .finally(() => {
             setPendingOperations(prev => ({ ...prev, addToBank: false }));
             // Ensure processing flags are cleared even if some remain
             setGeneratedCards(prev => prev.map(c => ({...c, processing: false })));
         });

    } catch (error) {
      console.error("Error in handleAddAllCards:", error);
      setError(`Error preparing to add cards: ${error.message}`);
      setGeneratedCards(prev => prev.map(c => ({...c, processing: false }))); // Reset processing state
      setPendingOperations(prev => ({ ...prev, addToBank: false }));
    }
  };


  // Modal to show successfully added cards
  const renderSuccessModal = () => {
    if (!successModal.show) return null;
    const count = successModal.addedCards.length;
    
    return (
      <div className="success-modal-overlay">
        <div className="success-modal">
          <div className="success-icon">✓</div>
          <h3>{count} {count === 1 ? 'Card' : 'Cards'} Added!</h3>
          <div className="success-cards">
            {successModal.addedCards.slice(0, 5).map(card => (
              <div key={card.id} className="success-card-item" style={{backgroundColor: card.cardColor || '#ddd'}}>
                <span style={{color: getContrastColor(card.cardColor || '#ddd')}}>{(card.front || card.question || '').substring(0, 40)}...</span>
              </div>
            ))}
            {count > 5 && (
              <div className="success-more">+{count - 5} more</div>
            )}
          </div>
           {/*<button onClick={() => setSuccessModal({ show: false, addedCards: [] })}>Close</button>*/}
        </div>
      </div>
    );
  };


  // Regenerate cards using WebSocket - MODIFIED
  const handleRegenerateCards = () => {
    console.log("Regenerating cards via WebSocket...");
    // No need to manually set states, generateCards handles clearing cards/setting loading
    if (!isGenerating && isWsConnected) {
        generateCards(); // Call the refactored WebSocket function
    } else if (!isWsConnected) {
        setError("Cannot regenerate cards, not connected to service.");
    } else {
        console.log("Already generating, regenerate request ignored.");
    }
  };

  // Helper for contrast color on success modal items
  const getContrastColor = (hexColor) => {
     if (!hexColor) return '#000000'; // Default to black if no color
     try {
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.5 ? '#000000' : '#FFFFFF'; // Black text on light, White text on dark
     } catch (e) {
        console.error("Error calculating contrast color:", e);
        return '#000000';
     }
  };

  // Reset state after card operations (e.g., adding all)
  const resetAfterCardOperation = () => {
     console.log("Resetting state after card operation.");
     // Maybe reset to step 1 or close the modal?
     // setGeneratedCards([]); // Keep generated cards or clear? Depends on flow.
     // setFormData({ ... initial form state ... }); // Reset form?
     // setCurrentStep(1); // Go back to start?
     // Or just close the modal if applicable:
     // if (typeof onClose === 'function') onClose();

     // For now, just clear saved count and operation success flag
      setSavedCount(0);
      setOperationSuccess(false);
      // Optionally clear the generated cards list if the user is expected to start over
      // setGeneratedCards([]);
  };

  // Main function to render content based on currentStep
  const renderStepContent = () => {
    switch (currentStep) {
           case 1: // Exam Details
        return (
                   <div>
                       <h4>Step 1: Exam Details</h4>
                       {/* Exam Board Dropdown */}
                       <label>Exam Board:</label>
                       <select name="examBoard" value={formData.examBoard} onChange={handleChange}>
                           <option value="">Select Board</option>
                           {EXAM_BOARDS.map(board => <option key={board.value} value={board.value}>{board.label}</option>)}
              </select>
                       {/* Exam Type Dropdown */}
                       <label>Exam Type:</label>
                       <select name="examType" value={formData.examType} onChange={handleChange}>
                           <option value="">Select Type</option>
                           {EXAM_TYPES.map(type => <option key={type.value} value={type.value}>{type.label}</option>)}
              </select>
          </div>
        );
           case 2: // Subject Selection
        return (
                    <div>
                       <h4>Step 2: Subject</h4>
                        {/* Subject Dropdown */}
                       <label>Subject:</label>
                       <select name="subject" value={formData.subject} onChange={handleChange}>
                           <option value="">Select Subject</option>
                           {availableSubjects.map(sub => <option key={sub} value={sub}>{sub}</option>)}
              </select>
                       {/* OR New Subject Input */}
                       <label>Or Add New Subject:</label>
                <input
                  type="text"
                  name="newSubject"
                  value={formData.newSubject}
                  onChange={handleChange}
                           placeholder="e.g., Astrophysics"
                />
          </div>
        );
           case 3: // Topic Selection/Generation
        return (
                   <div>
                       <h4>Step 3: Topic</h4>
                        {isGenerating && loadingStatus && <div>{loadingStatus}... <div className="spinner"></div></div>}
                        {error && <div className="error-message">{error}</div>}
                        {availableTopics.length > 0 && !isGenerating && (
                             <>
                                {/* Topic Dropdown */}
                               <label>Select Topic:</label>
                               <select name="topic" value={formData.topic} onChange={handleChange}>
                                   <option value="">Select Topic</option>
                                   {availableTopics.map(t => (
                                       <option key={t.id || t.topic} value={t.id || t.topic}>
                                           {t.topic} {t.subtopic ? `(${t.subtopic})` : ''}
                                       </option>
                                   ))}
                               </select>
                               {/* OR New Topic Input */}
                               <label>Or Add New Topic:</label>
                               <input
                                   type="text"
                                   name="newTopic"
                                   value={formData.newTopic}
                                   onChange={handleChange}
                                   placeholder="e.g., Black Holes"
                               />
                                {/* Optionally, button to regenerate topics */}
                               <button onClick={() => generateTopics(formData.examBoard, formData.examType, formData.subject || formData.newSubject)} disabled={isGenerating || !isWsConnected}>
                                   Regenerate Topics
                               </button>
                             </>
                         )}
                         {/* Show if topics haven't loaded and not currently generating */}
                          {!isGenerating && availableTopics.length === 0 && !error && (
                               <div>No topics generated yet. Check Subject/Exam details or try regenerating.</div>
                          )}
                          {/* Button to trigger generation if not auto-triggered */}
                           {!isGenerating && availableTopics.length === 0 && !error && (
                                <button onClick={() => generateTopics(formData.examBoard, formData.examType, formData.subject || formData.newSubject)} disabled={!isWsConnected || !(formData.subject || formData.newSubject)}>
                                   Generate Topics Now
                               </button>
                           )}
          </div>
        );
           case 4: // Card Options
        return (
                    <div>
                       <h4>Step 4: Card Options</h4>
                       {/* Number of Cards Input */}
                       <label>Number of Cards:</label>
              <input 
                type="number" 
                name="numCards" 
                value={formData.numCards} 
                onChange={handleChange}
                min="1" 
                           max="20" // Set a reasonable max
                       />
                       {/* Question Type Dropdown */}
                       <label>Question Type:</label>
                       <select name="questionType" value={formData.questionType} onChange={handleChange}>
                           {QUESTION_TYPES.map(type => <option key={type.value} value={type.value}>{type.label}</option>)}
                       </select>
                       {/* Optional: Add difficulty selector here */}
          </div>
        );
           case 5: // Review Generated Cards
        return (
                   <div>
                       <h4>Step 5: Review & Add Cards</h4>
                        {isGenerating && loadingStatus && <div>{loadingStatus}... <div className="spinner"></div></div>}
                        {error && <div className="error-message">{error}</div>}
            <div className="generated-cards-container">
                            {generatedCards.length > 0 && !isGenerating ? (
                                generatedCards.map((card, index) => (
                                    <div key={card.id || index} className="generated-card-review-item">
                                         {/* Basic card preview - could use Flashcard component */}
                                         <div className="card-preview" style={{ borderLeft: `5px solid ${card.cardColor}` }}>
                                            <strong>Q:</strong> {card.front?.substring(0, 100)}{card.front?.length > 100 ? '...' : ''} <br />
                                             <strong>A:</strong> {card.back?.substring(0, 100)}{card.back?.length > 100 ? '...' : ''}
                  </div>
                                         <button onClick={() => handleAddCard(card)} disabled={pendingOperations.addToBank || card.processing}>
                                             {card.processing ? 'Adding...' : 'Add This Card'}
              </button>
                                         {/* Add edit/delete buttons if needed */}
            </div>
                                ))
                            ) : (
                                !isGenerating && <div>No cards generated yet.</div>
        )}
      </div>
                        {generatedCards.length > 0 && !isGenerating && (
                             <div className="card-actions">
                                 <button onClick={handleAddAllCards} disabled={pendingOperations.addToBank || isGenerating}>
                                     Add All {generatedCards.length} Cards
            </button>
                                 <button onClick={handleRegenerateCards} disabled={pendingOperations.addToBank || isGenerating || !isWsConnected}>
                                     Regenerate Cards
            </button>
                      </div>
                    )}
                         {savedCount > 0 && <div className="saved-count-indicator">{savedCount} card(s) added.</div>}
      </div>
    );
           default:
               return <div>Unknown step</div>;
       }
   };


  // --- Other potential functions (need review/update) ---

  const handleRegenerateTopics = async () => {
    // This might be redundant if generateTopics covers it
     console.log("Regenerating topics...");
      if (!isGenerating && isWsConnected && (formData.subject || formData.newSubject)) {
         generateTopics(formData.examBoard, formData.examType, formData.subject || formData.newSubject);
     } else {
         setError("Cannot regenerate topics. Check subject/connection or wait for current operation.");
     }
  };

  const addAllToBank = async (stableExamType, stableExamBoard, stableSubject, stableTopic) => {
      // This function seems to be called by handleAddAllCards.
      // The logic should primarily live within handleAddAllCards now, using the SaveQueueService.
      // Keeping the signature here for reference, but the implementation is effectively moved.
      console.warn("addAllToBank function is deprecated; logic moved to handleAddAllCards.");
      // Ensure handleAddAllCards covers all necessary steps.
       handleAddAllCards(); // Redirect call, though parameters are now derived inside handleAddAllCards
  };

  // sendMessageWithRetry might be useful for critical parent communication, but not needed for WS generation itself
  const sendMessageWithRetry = async (type, data, maxRetries = 3) => {
      // ... (Implementation for sending messages via window.postMessage with retry)
       console.warn("sendMessageWithRetry is for parent communication, not WebSocket.");
       // Example for parent comms:
       if (window.parent && window.parent !== window) {
           // ... logic to postMessage with retry ...
              } else {
           console.error("Cannot send message: No parent window detected.");
       }
  };

   // Close handler
  const handleClose = () => {
      console.log("AICardGenerator closing.");
      // Reset state?
       setGeneratedCards([]);
       setAvailableTopics([]);
       setError(null);
       setIsGenerating(false);
       setLoadingStatus('');
       // Call the onClose prop if provided
       if (typeof onClose === 'function') {
      onClose();
    }
  };
 // --- End Other Functions ---

  return (
      <div className="ai-card-generator-modal">
           {renderSuccessModal()} {/* Render success modal */}
           <div className="modal-content">
              <button className="close-button" onClick={handleClose}>×</button>
              <h2>AI Flashcard Generator</h2>

              {/* Progress Indicator */}
              <div className="progress-indicator">
                  Step {currentStep} of {totalSteps}
                  <div className="progress-bar-container">
                      <div className="progress-bar" style={{ width: `${(currentStep / totalSteps) * 100}%` }}></div>
          </div>
      </div>
      
              {/* Render content for the current step */}
               <div className="step-content">
        {renderStepContent()}
      </div>
      
               {/* Display general errors */}
              {error && currentStep !== 5 && <div className="error-message general-error">{error}</div>}

               {/* Navigation Buttons */}
              <div className="navigation-buttons">
                  <button onClick={handlePrevStep} disabled={currentStep === 1}>
                      Previous
          </button>
                  <button onClick={handleNextStep} disabled={currentStep === totalSteps || isGenerating || !canProceed()}>
                      {currentStep === totalSteps -1 ? 'Generate & Review Cards' : 'Next'}
          </button>
      </div>
      
               {/* WebSocket Status Indicator */}
                <div className={`ws-status ${isWsConnected ? 'connected' : 'disconnected'}`}>
                    {isWsConnected ? 'Connected to Generation Service' : 'Disconnected - Retrying...'}
                </div>
           </div>
    </div>
  );
};

export default AICardGenerator;